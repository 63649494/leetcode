/*****************
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。


上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:

输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
示例 2:

输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
说明:

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 '.' 。
给定数独永远是 9x9 形式的。


********************/

int CompareR(char arr[],int boardRowSize){
    for(int i=0;i<boardRowSize;i++){
        if(arr[i]=='.')
            continue;
        else{ 
                for(int j=i+1;j<boardRowSize;j++){
                //printf("%d,%d,%c,%c\n",i,j,arr[i],arr[j]);
                if(arr[j]=='.')
                continue;
                else{
                    if(arr[i]==arr[j])
                        return 1;//重复假
                }
            }
        }
    }
    return 0;
}


bool isValidSudoku(char** board, int boardRowSize, int boardColSize) {
    //数字 1-9 在每一行只能出现一次。
    for(int i=0;i<boardRowSize;i++)
        if(CompareR(board[i],boardRowSize)==1){
            printf("R false");
            return false;
        }
            
        //数字 1-9 在每一列只能出现一次。
    for(int i=0;i<boardRowSize;i++){
        for(int j=0;j<boardColSize;j++)
            if(board[j][i]=='.')
            continue;
        else{ 
              for(int k=j+1;k<boardColSize;k++){
                if(board[k][i]=='.')
                continue;
                else{
                    if(board[k][i]==board[j][i]){
                        printf("C false");
                        return false;//重复假
                    }
                        
                }
            }
        }
    }
            //数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
    int a=0,b=0;
    for(int i=0;i<9;i++){
    //小九宫格中的查重，将二维数组里的值提取到一维数组中降低时间复杂度
        char arr[]={board[a][b],board[a][b+1],board[a][b+2],board[a+1][b],board[a+1][b+1],board[a+1][b+2],board[a+2][b],board[a+2][b+1],board[a+2][b+2]};
        for(int o=0;o<9;o++)
            printf("%c ",arr[o]);
        printf("\n");
        for(int j=0;j<9;j++){
            //if(arr[i]=='.') continue;
            for(int k=j+1;k<9;k++){
                if(arr[k]=='.') continue;
                if(arr[k]==arr[j]){
                    printf("\nA false");
                    return false;
                }
            }
        }
        //换行
        if(b==6){
            a=a+3;
            b=0;
        }
        else b=b+3;
    }

    return true;
}