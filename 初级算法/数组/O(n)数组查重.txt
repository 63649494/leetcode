//查重（条件：在一个长度为n的数组里的所有数字都在0到n-1的范围内）
//时间复杂度O(n)；空间复杂度O(1)的解法。思路是这样的：因为如果不重复的，那么，使之有序之后一定是对应位置是对应的数，即：下标和数是一样的。那么我利用这个性质，把数和下标不同的数换到对应位置！当交换的两个数相同的时候，说明有重复数字，记录并返回！

int CompareR(int arr,int boardRowSize){
    for(int i=0;i<boardRowSize;i++){
        if(arr[i]!=i)
            
    }
}